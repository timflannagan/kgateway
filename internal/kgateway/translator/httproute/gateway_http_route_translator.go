package httproute

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"regexp"
	"strings"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/sets"
	gwv1 "sigs.k8s.io/gateway-api/apis/v1"

	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/ir"

	"github.com/kgateway-dev/kgateway/v2/internal/kgateway/query"
	reports "github.com/kgateway-dev/kgateway/v2/pkg/pluginsdk/reporter"
)

// Path validation constants
var (
	validPathRegex       = regexp.MustCompile(`^[a-zA-Z0-9\-._~:/?#[\]@!$&'()*+,;=]*$`)
	invalidPathSequences = []string{
		"//",
		"/./",
		"/../",
	}
	invalidPathSuffixes = []string{
		"/.",
		"/..",
	}
)

// TODO: Uncomment when the gateway_http_route_translator_test.go is uncommented.
// var (
// 	awsMissingFuncRefError                = eris.New("upstreams must have a logical name specified in the backend ref via the parameters extensionref")
// 	azureMissingFuncRefError              = eris.New("upstreams must have a function name specified in the backend ref via the parameters extensionref")
// 	nonFunctionUpstreamWithParameterError = eris.New("parameters extensionref is only supported for aws and azure upstreams")
// )

func TranslateGatewayHTTPRouteRules(
	ctx context.Context,
	routeInfo *query.RouteInfo,
	reporter reports.ParentRefReporter,
	baseReporter reports.Reporter,
) []ir.HttpRouteRuleMatchIR {
	var finalRoutes []ir.HttpRouteRuleMatchIR
	routesVisited := sets.New[types.NamespacedName]()

	// Only HTTPRoute types should be translated.
	_, ok := routeInfo.Object.(*ir.HttpRouteIR)
	if !ok {
		return finalRoutes
	}

	translateGatewayHTTPRouteRulesUtil(
		ctx, routeInfo, reporter, baseReporter, &finalRoutes, routesVisited, nil)
	return finalRoutes
}

// translateGatewayHTTPRouteRulesUtil is a helper to translate an HTTPRoute.
// In case of route delegation, this function is recursively invoked to flatten the delegated route tree.
func translateGatewayHTTPRouteRulesUtil(
	ctx context.Context,
	routeInfo *query.RouteInfo,
	reporter reports.ParentRefReporter,
	baseReporter reports.Reporter,
	outputs *[]ir.HttpRouteRuleMatchIR,
	routesVisited sets.Set[types.NamespacedName],
	delegatingParent *ir.HttpRouteRuleMatchIR,
) {
	// Only HTTPRoute types should be translated.
	route, ok := routeInfo.Object.(*ir.HttpRouteIR)
	if !ok {
		return
	}

	for ruleIdx, rule := range route.Rules {
		if len(rule.Matches) == 0 {
			// from the spec:
			// If no matches are specified, the default is a prefix path match on "/*", which has the effect of matching every HTTP request.
			rule.Matches = []gwv1.HTTPRouteMatch{{}}
		}

		outputRoutes := translateGatewayHTTPRouteRule(
			ctx,
			routeInfo,
			route,
			rule,
			ruleIdx,
			reporter,
			baseReporter,
			outputs,
			routesVisited,
			delegatingParent,
		)
		for _, outputRoute := range outputRoutes {
			// The above function will return a nil route if a matcher fails to apply plugins
			// properly. This is a signal to the caller that the route should be dropped.
			//		if outputRoute == nil {
			//			continue
			//		}

			*outputs = append(*outputs, outputRoute)
		}
	}
}

// MARK: translate rules
func translateGatewayHTTPRouteRule(
	ctx context.Context,
	gwroute *query.RouteInfo,
	parent *ir.HttpRouteIR,
	rule ir.HttpRouteRuleIR,
	ruleIdx int,
	reporter reports.ParentRefReporter,
	baseReporter reports.Reporter,
	outputs *[]ir.HttpRouteRuleMatchIR,
	routesVisited sets.Set[types.NamespacedName],
	delegatingParent *ir.HttpRouteRuleMatchIR,
) []ir.HttpRouteRuleMatchIR {
	routes := make([]ir.HttpRouteRuleMatchIR, 0, len(rule.Matches))

	for idx, match := range rule.Matches {
		// HTTPRoute names are being introduced to upstream as part of https://github.com/kubernetes-sigs/gateway-api/issues/995
		// For now, the HTTPRoute needs a unique name for each Route to support features that require the route name
		// set (basic ratelimit, route-level jwt, etc.). The unique name is generated by appending the index of the route to the
		// HTTPRoute name.namespace.
		uniqueRouteName := gwroute.UniqueRouteName(ruleIdx, idx)

		outputRoute := ir.HttpRouteRuleMatchIR{
			ExtensionRefs:     rule.ExtensionRefs,
			AttachedPolicies:  rule.AttachedPolicies,
			Parent:            parent,
			ListenerParentRef: gwroute.ListenerParentRef,
			ParentRef:         gwroute.ParentRef,
			Name:              uniqueRouteName,
			Backends:          nil,
			MatchIndex:        idx,
			Match:             match,
			DelegatingParent:  delegatingParent,
		}

		if len(rule.Backends) > 0 {
			setRouteAction(
				ctx,
				gwroute,
				rule,
				&outputRoute,
				reporter,
				baseReporter,
				match,
				outputs,
				routesVisited,
			)
		}

		// Validate the route
		if err := validateRoute(outputRoute); err != nil {
			reporter.SetCondition(reports.RouteCondition{
				Type:    gwv1.RouteConditionAccepted,
				Status:  metav1.ConditionFalse,
				Reason:  gwv1.RouteReasonUnsupportedValue,
				Message: fmt.Sprintf("Route validation failed: %v", err),
			})
			continue
		}

		routes = append(routes, outputRoute)
	}
	return routes
}

func setRouteAction(
	ctx context.Context,
	gwroute *query.RouteInfo,
	rule ir.HttpRouteRuleIR,
	outputRoute *ir.HttpRouteRuleMatchIR,
	reporter reports.ParentRefReporter,
	baseReporter reports.Reporter,
	match gwv1.HTTPRouteMatch,
	outputs *[]ir.HttpRouteRuleMatchIR,
	routesVisited sets.Set[types.NamespacedName],
) {
	backends := rule.Backends
	// this was coming from internal/kgateway/translator/gateway/gateway_translator.go
	// TODO: scope this to httproute?
	logger := slog.Default()

	for _, backend := range backends {
		// If the backend is an HTTPRoute, it implies route delegation
		// for which delegated routes are recursively flattened and translated
		if backend.Delegate != nil {
			outputRoute.Delegates = true
			// Flatten delegated HTTPRoute references
			err := flattenDelegatedRoutes(
				ctx,
				gwroute,
				backend,
				reporter,
				baseReporter,
				match,
				outputs,
				routesVisited,
				outputRoute,
			)
			if err != nil {
				query.ProcessBackendError(err, reporter)
			}
			continue
		}

		if err := backend.Backend.Err; err != nil {
			query.ProcessBackendError(err, reporter)
			logger.Debug("error on backend upstream", "error", err)
		}

		httpBackend := ir.HttpBackend{
			Backend:          *backend.Backend, // TODO: Nil check?
			AttachedPolicies: backend.AttachedPolicies,
		}
		outputRoute.Backends = append(outputRoute.Backends, httpBackend)
	}
}

/* TODO: demonstrate that we can replace this with 'virtual' GKs
func applyBackendPlugins(
	obj client.Object,
	backendRef gwv1.BackendObjectReference,
	plugins registry.PluginRegistry,
) (*v1.Destination, bool) {
	for _, bp := range plugins.GetBackendPlugins() {
		if dest, ok := bp.ApplyBackendPlugin(obj, backendRef); ok {
			return dest, true
		}
	}
	return nil, false
}
*/

// validateRoute validates a route and its components
func validateRoute(route ir.HttpRouteRuleMatchIR) error {
	var errs []error

	// Validate path match
	if route.Match.Path != nil && route.Match.Path.Value != nil {
		if err := validatePath(*route.Match.Path.Value); err != nil {
			errs = append(errs, fmt.Errorf("invalid path match: %w", err))
		}
	}

	// Validate backends
	if len(route.Backends) == 0 && !route.Delegates {
		errs = append(errs, errors.New("route must have at least one backend or delegate"))
	}

	// Validate policy attachments
	for gk, policies := range route.AttachedPolicies.Policies {
		for _, policy := range policies {
			if len(policy.Errors) > 0 {
				errs = append(errs, fmt.Errorf("policy %s/%s errors: %s", gk.Group, gk.Kind, policy.FormatErrors()))
			}
		}
	}

	if len(errs) == 0 {
		return nil
	}
	return fmt.Errorf("route validation failed: %w", errors.Join(errs...))
}

// validatePath validates a path according to RFC 3986
func validatePath(path string) error {
	if path == "" {
		return nil
	}

	// Validate path characters
	if !validPathRegex.Match([]byte(path)) {
		return fmt.Errorf("path contains invalid characters: %s", path)
	}

	// Check for invalid sequences
	for _, invalid := range invalidPathSequences {
		if strings.Contains(path, invalid) {
			return fmt.Errorf("path contains invalid sequence %s: %s", invalid, path)
		}
	}

	// Check for invalid suffixes
	for _, invalid := range invalidPathSuffixes {
		if strings.HasSuffix(path, invalid) {
			return fmt.Errorf("path ends with invalid suffix %s: %s", invalid, path)
		}
	}

	return nil
}
